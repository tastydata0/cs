# Функции

> Функция - это набор инструкций, которые выполняют определенную задачу. Функция может принимать аргументы и возвращать значение. Функции позволяют повторно использовать код, а также упрощают его чтение и понимание.

При вызове функции **управление передается на ее тело, а затем возвращается обратно на место вызова**. Все переменные, объявленные внутри функции, существуют только внутри нее. При выходе из функции все переменные удаляются.

## Синтаксис объявления функции:
```c++
тип_возвращаемого_значения имя_функции(аргументы) {
    // тело функции
}

int sum(int a, int b) {
    return a + b;
}

void printHello() {
    cout << "Hello" << endl;
}
```

> **Return** - это оператор, который **прерывает выполнение функции и возвращает значение**. Возвращаемое значение **подставляется на место вызова функции**. Если функция не возвращает значение, то return можно не писать. Значение, которое мы пишем после return, должно быть того же типа, что и тип возвращаемого значения функции.

> **Void** - это тип, который **не возвращает никакого значения**. Такие функции называются процедурами или методами. То есть void функция может что-то делать, но не возвращать никакого значения. А **non-void** функция всегда возвращает значение.

## Синтаксис вызова функции:
```c++
имя_функции(аргументы);
swap(a, b);
```

## Синтаксис аргументов функции:
```c++
(тип_аргумента имя_аргумента, тип_аргумента имя_аргумента, ...)
(int a, string b, float c, long long d)
```

Пример:
```c++
#include <iostream>

using namespace std;

// Функция, которая суммирует два числа
int sum(int a, int b) {
    return a + b;
}

int main() {
    int a, b;
    cin >> a >> b;
    cout << sum(a, b) << endl;
    return 0;
}
```
Функция sum принимает два аргумента типа int и возвращает значение типа int.
main - тоже функция, но особая. Она вызывается сама себя, когда программа запускается. Тип её возвращаемого значения int - код завершения программы. Если код завершения равен нулю, то программа завершилась успешно. Если код завершения не равен нулю, то программа завершилась с ошибкой.

Мы уже сталкивались с вызовом множества функций, например: 
> - swap(int, int)
> - min(int, int)
> -  max(int, int)
> - sort(int[], int)
> - abs(int) 

Еще пример:
```c++
#include <iostream>

using namespace std;

void greet() {
    cout << "Hello" << endl;
    cout << "How are you?" << endl;
}

void printGoodbye() {
    cout << "K THX BYE" << endl;
    cout << "Goodbye" << endl;
}

int main() {
    greet();
    cout << "I like c++!" << endl;
    printGoodbye();
    return 0;
}
```

Программа выведет на экран:
```
Hello
How are you?
I like c++!
K THX BYE
Goodbye
```

## Прототипы функций

> Прототип функции - это объявление функции, которое содержит только имя функции, тип возвращаемого значения и типы аргументов и **не содержит тело функции**. Прототип функции позволяет использовать функцию до ее объявления. *Мы говорим компилятору: "Эта функция существует, но ее тело будет объявлено позже"*.

Пример:
```c++
#include <iostream>

using namespace std;

// Прототип функции
int sum(int a, int b);

int main() {
    int a, b;
    cin >> a >> b;
    cout << sum(a, b) << endl;
    return 0;
}

// Тело функции
int sum(int a, int b) {
    return a + b;
}
```

Если мы не объявим прототип функции, то программа не скомпилируется, так как на этапе вызова `sum()` компилятор не знает, что такое функция `sum()`. Получается, что до вызова функции должно быть объявление функции или её прототипа.


## Перегрузка функций

> Перегрузка функций - это возможность объявлять несколько функций с одинаковым именем, но с разным набором аргументов. При этом компилятор сам выбирает, какую функцию вызывать.

Пример:
```c++

#include <iostream>

using namespace std;

// Функция 1
int sum(int a, int b) {
    return a + b;
}

// Функция 2
int sum(int a, int b, int c) {
    return a + b + c;
}

// Функция 3
float sum(float a, float b) {
    return a + b;
}

int main() {
    int a, b, c;
    cin >> a >> b >> c;
    cout << sum(a, b) << endl; // вызовется функция 1
    cout << sum(a, b, c) << endl; // вызовется функция 2
    float x, y;
    cin >> x >> y;
    cout << sum(x, y) << endl; // вызовется функция 3
    return 0;
}
```

## Стек и куча

> **Стек** - это область памяти, которая выделяется для функции при ее вызове. При вызове функции в стеке выделяется область памяти, в которой хранятся все локальные переменные функции, аргументы функции и возвращаемое значение.
<br> 
<h3><span style="color:red"><strong>Важно!</strong></span></h3>

> **При возврате из функции эта область памяти освобождается, то есть уничтожаются все локальные переменные, созданные в функции!**

> **Куча** - это область памяти, которая выделяется во время выполнения программы. Память в куче выделяется динамически, то есть во время выполнения программы. Память в куче выделяется с помощью оператора new. Память в куче освобождается с помощью оператора delete.<br>
Подробнее поговорим об этом на теме "Указатели".

# Практика

1. Описать функцию `invDigits(int)`, меняющую порядок следования цифр целого положительного числа k на обратный. Вернуть число с цифрами, записанными в обратном порядке.
2. Описать процедуру `sort3(float, float, float)`, сортирующую последовательность из 3 вещественных значений. При этом результат нужно записать во входные переменные.
3. (Самостоятельно): Описать функцию `addRightDigit(int, int)`, добавляющую к целому числу цифру из 2 аргумента справа. То есть `addRightDigit(123, 4)` должна вернуть 1234. Не делайне *овнокод, делайте без всяких to_string.
4. (Самостоятельно):  Описать процедуру `shiftRight3(int a, int b, int c)`, выполняющую правый циклический сдвиг: значение A переходит в B, значение B — в C, значение C — в A. Процедура ничего не должна возвращать, а записывать новые значения в оригиналы переданных переменных.
5. (ДЗ): Описать функцию `addLeftDigit(int, int)`, добавляющую к целому числу цифру из 2 аргумента слева. То есть `addLeftDigit(123, 4)` должна вернуть 4123. Не делайне *овнокод, делайте без всяких to_string.