# Рекурсия в C++

Самое точное определение:
> Рекурсия - это ( см. [Рекурсия]() )

Второе определение:

> Рекурсия - это техника программирования, при которой функция вызывает саму себя. Рекурсивная функция состоит из двух частей: базовый случай и рекурсивный случай.
---

<img width="300px" src="https://media.makeameme.org/created/to-understand-recursion.jpg">

<img width="300px" src="https://cs10.pikabu.ru/post_img/2019/09/19/6/1568885695152069210.png">
</center>

---

## Базовый случай (base case)

> Базовый случай - это случай, в котором функция не вызывает саму себя. Это необходимо, чтобы предотвратить бесконечную рекурсию и остановить выполнение функции.
## Рекурсивный случай

> Рекурсивный случай - это случай, в котором функция вызывает саму себя. Обычно при каждом вызове функция обрабатывает задачу, которая меньше по размеру, чем исходная задача. Этот процесс продолжается до тех пор, пока не будет достигнут базовый случай.
## Пример рекурсивной функции
```c++
#include <iostream>

using namespace std;

int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int main() {
    int n = 5;
    int result = factorial(n);
    cout << "Факториал числа " << n << " равен " << result << endl;
    return 0;
}
```

В этом примере рекурсивная функция factorial вычисляет факториал числа n. Если n равно 0, то функция возвращает 1 (базовый случай). Иначе функция вызывает саму себя с аргументом n - 1 и возвращает произведение n и результата вызова factorial(n - 1).

В функции main мы вызываем функцию factorial с аргументом 5 и выводим результат на экран.

*( Факториалом натурального числа n называется произведение всех натуральных чисел от 1 до n. Обозначается факториал числа n при помощи восклицательного знака, т.е. вот так: n! )*

## Частая ошибка при создании рекурсивной функции
Если не сделать базовый случай, то рекурсивная функция будет вызывать саму себя бесконечное количество раз, что приведет к ошибке переполнения стека (stack overflow). Это происходит потому, что каждый раз, когда функция вызывает саму себя, на стек помещается новый экземпляр функции, и если количество этих экземпляров бесконечно, то стек переполнится.

Например, если мы напишем следующую рекурсивную функцию, которая не имеет базового случая:
```c++
void infiniteRecursion() {
    infiniteRecursion();
}

int main() {
    infiniteRecursion();
    return 0;
}
```
То программа будет работать бесконечно долго и не выдаст никакого результата. Если же мы добавим базовый случай, то программа завершится:

```cpp
void finiteRecursion(int n) {
    if (n == 0) {
        return;
    } else {
        cout << n << endl;
        finiteRecursion(n - 1);
    }
}

int main() {
    finiteRecursion(5);
    return 0;
}
```
В этом примере рекурсивная функция finiteRecursion выводит на экран числа от n до 1. Базовый случай - это случай, когда n равно 0, и в этом случае функция просто возвращает управление. Если n больше 0, то функция выводит на экран значение n, а затем вызывает саму себя с аргументом n - 1. Таким образом, функция будет вызвана рекурсивно n раз, после чего завершит свою работу.
> Вопрос: как можно изменить функцию finiteRecursion, чтобы она выводила числа от 1 до n?

<img src="https://i.pinimg.com/originals/fc/09/2e/fc092ecfa54cecbef34cb4745b9f6b42.png">

## Практика
1. Описать рекурсивную функцию fact(n), вычис-ляющую значение факториала n. С помощью этой функции вычислить факториалы пяти разных чисел 2~10.
2. Описать рекурсивную функцию fib(n), вычисляющую n-й элемент последовательности чисел Фибоначчи. ( $F_1 = F_2 = 1, F_K = F_{K-2} + F_{K−1}$ ). Попробовать функцию на нескольких тестах.
3. Описать рекурсивную функцию gcd(a, b), находящую наибольший общий делитель (НОД) двух целых положительных чисел a и b, используя алгоритм Евклида: $НОД(a, b) = НОД(b$, $a$ $mod$ $b$), если $B \ne 0$; $НОД(A, 0) = A.$ Попробовать функцию на нескольких тестах.
4. Описать рекурсивную функцию digitSum(k), которая находит сумму цифр целого числа k, не используя оператор цикла. Попробовать функцию на нескольких тестах.