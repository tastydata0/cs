# Указатели

<img src="index.jpg">

> Указатель - это переменная, которая хранит адрес другой переменной. Указатели используются для доступа к данным, которые хранятся в других частях памяти. Указатели могут быть использованы для передачи больших массивов в функцию, для возврата нескольких значений из функции, для динамического выделения памяти и для реализации связанных списков и других структур данных.

## Объявление указателя
Объявление указателя происходит с помощью оператора `*`:
```c++
int *p; // p - указатель на переменную типа int
float *q; // q - указатель на переменную типа float
int **r; // r - указатель на указатель на переменную типа int
```

## Операторы
Операторы, которые используются для работы с указателями:
* `&` - возвращает адрес переменной
* `*` - возвращает значение переменной, которая хранится по адресу, который хранится в указателе
* `->` - возвращает значение переменной, которая хранится по адресу, который хранится в указателе (используется для обращения к полям переменной, указатель на которую мы имеем)

Пример:
```c++
#include <iostream>

using namespace std;

int main() {
    int a = 5;
    int *p = &a; // p хранит адрес переменной a
    cout << p << endl; // 0x7ffeeb5b9f7c
    cout << *p << endl; // 5
    return 0;
}
```

<p align="center"><img src="How-Pointer-Works-In-C.png"/></p>

## Указатели и массивы
Указатели могут быть использованы для доступа к элементам массива. Для этого используется оператор `[]`:
```c++
int main() {
    int a[5] = {1, 2, 3, 4, 5};
    int *p = a; // p хранит адрес первого элемента массива a
    cout << p[0] << endl; // 1
    cout << p[1] << endl; // 2
    cout << p[2] << endl; // 3
    cout << p[3] << endl; // 4
    cout << p[4] << endl; // 5
    return 0;
}
```

> На самом деле обращение по индексу массива `p[i]` эквивалентно обращению по указателю `*(p + i)`:
```c++
int main() {
    int a[5] = {1, 2, 3, 4, 5};
    int *p = a; // p хранит адрес первого элемента массива a
    cout << *(p + 0) << endl; // 1
    cout << *(p + 1) << endl; // 2
    cout << *(p + 2) << endl; // 3
    cout << *(p + 3) << endl; // 4
    cout << *(p + 4) << endl; // 5
    return 0;
}
```
> Теперь вы знаете, что при обращении по индексу массива просто складывается адрес первого элемента массива с индексом. Именно поэтому работает такой код, в котором также складывается адрес массива с индексом:
```c++
int main() {
    int a[5] = {1, 2, 3, 4, 5};
    cout << 0[a] << endl; // 1
    cout << 1[a] << endl; // 2
    cout << 2[a] << endl; // 3
    cout << 3[a] << endl; // 4
    cout << 4[a] << endl; // 5
    // Но так делать не стоит
    return 0;
}
```

## Динамическое выделение памяти
Для динамического выделения памяти используется оператор `new`:
```c++
int main() {
    int *p = new int; // выделяем память под одну переменную типа int
    *p = 5; // присваиваем значение 5
    cout << *p << endl; // 5
    delete p; // освобождаем память
    return 0;
}
```
> Обычно оператор `new` используется для выделения памяти под массив:
```c++
int main() {
    int *p = new int[5]; // выделяем память под 5 переменных типа int
    p[0] = 1;
    p[1] = 2;
    p[2] = 3;
    p[3] = 4;
    p[4] = 5;
    cout << p[0] << endl; // 1
    cout << p[1] << endl; // 2
    cout << p[2] << endl; // 3
    cout << p[3] << endl; // 4
    cout << p[4] << endl; // 5
    delete[] p; // освобождаем память
    return 0;
}
```

> Зачем выделять память под массив, если можно просто объявить массив? Потому что во-первых, размер массива может быть неизвестен во время компиляции. Динамическое выделение допускает заранее неизвестный размер массива. <br>А во-вторых, массивы, объявленные внутри функции, хранятся в стеке, а не в куче. Поэтому если массив объявлен внутри функции, то он будет уничтожен после выхода из функции. А если массив объявлен вне функции, то он будет храниться в куче, а не в стеке, и его можно будет использовать в других функциях.

## Создание сложных типов данных в динамической памяти

Пример создания vector:
```c++
#include <vector>
#include <iostream>
using namespace std;

int main() {
  vector<int>* myVector = new vector<int>;
  myVector->push_back(5);
  cout << myVector->at(0) << endl;
  delete myVector;
  return 0;
}
```

Пример создания pair:
```c++
#include <iostream>
using namespace std;

int main() {
  pair<int, char>* myPair = new pair<int, char>(5, 'a');
  cout << myPair->first << ", " << myPair->second << endl;
  delete myPair;
  return 0;
}
```

> В обоих случаях точка заменяется на `->`, потому что мы обращаемся не к самой переменной, а к указателю. Впрочем, можно разыменовать указатель и обратиться через точку, но стрелка удобнее.

## ДЗ
1. Создать функцию, которая принимает имя файла и возвращает указатель на ifstream, созданный через new, в который передано имя файла.

2. Также напишите функцию, которая принимает указатель на ifstream, закрывает открытый файл и очищает память через delete.

3. Создайте функцию, которая получает имя файла, открывает файл через функцию из п. 1, считывает все строки в vector<string>, созданный через new, закрывает файл (функция из п. 2) и возвращает указатель на вектор строк. В итоге получается функция, возвращающая содержимое файла по имени файла.

4. Запрашивайте у пользователя имя файла и выводите содержимое файла. Если вы сделали, как я написал, то ваша программа будет работать хорошо и быстро, т.к. в ней не будет копирования больших данных. Советую зациклить ввод, чтобы не перезапускать программу по много раз. Не забывайте очищать память, занятую содержимым файла перед открытием нового.

В итоге получится программа-просмотрщик ascii-артов. Я нашел несколько, чтобы вы потестировали программу. Они лежат в папке ascii_arts, рядом с этим конспектом. Время у вас до следующего занятия в четверг.
